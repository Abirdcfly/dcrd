// Copyright (c) 2021 The Decred developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package uint256

import (
	"bytes"
	"encoding/hex"
	"math/big"
	"math/rand"
	"reflect"
	"testing"
	"time"
)

// hexToBytes converts the passed hex string into bytes and will panic if there
// is an error.  This is only provided for the hard-coded constants so errors in
// the source code can be detected. It will only (and must only) be called with
// hard-coded values.
func hexToBytes(s string) []byte {
	b, err := hex.DecodeString(s)
	if err != nil {
		panic("invalid hex in source file: " + s)
	}
	return b
}

// hexToUint256 converts the passed hex string into a Uint256 and will panic if
// there is an error.  This is only provided for the hard-coded constants so
// errors in the source code can be detected. It will only (and must only) be
// called with hard-coded values.
func hexToUint256(s string) *Uint256 {
	if len(s)%2 != 0 {
		s = "0" + s
	}
	b := hexToBytes(s)
	if len(b) > 32 {
		panic("hex in source file overflows mod 2^256: " + s)
	}
	return new(Uint256).SetByteSlice(b)
}

// randBigIntAndUint256 returns a big integer and a uint256 both created from
// the same random value generated by the passed rng.
func randBigIntAndUint256(t *testing.T, rng *rand.Rand) (*big.Int, *Uint256) {
	t.Helper()

	var buf [32]byte
	if _, err := rng.Read(buf[:]); err != nil {
		t.Fatalf("failed to read random: %v", err)
	}

	// Create and return both a big integer and a uint256.
	bigIntVal := new(big.Int).SetBytes(buf[:])
	ui256Val := new(Uint256).SetBytes(&buf)
	return bigIntVal, ui256Val
}

// TestUint256SetUint64 ensures that setting a scalar to various native integers
// works as expected.
func TestUint256SetUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string    // test description
		n    uint64    // test value
		want [4]uint64 // expected words
	}{{
		name: "five",
		n:    0x5,
		want: [4]uint64{0x5, 0, 0, 0},
	}, {
		name: "2^32 - 1",
		n:    0xffffffff,
		want: [4]uint64{0xffffffff, 0, 0, 0},
	}, {
		name: "2^32",
		n:    0x100000000,
		want: [4]uint64{0x100000000, 0, 0, 0},
	}, {
		name: "2^64 - 1",
		n:    0xffffffffffffffff,
		want: [4]uint64{0xffffffffffffffff, 0, 0, 0},
	}}

	for _, test := range tests {
		n := new(Uint256).SetUint64(test.n)
		if !reflect.DeepEqual(n.n, test.want) {
			t.Errorf("%s: wrong result -- got: %x want: %x", test.name, n.n,
				test.want)
			continue
		}
	}
}

// TestUint256SetBytes ensures that setting a uint256 to a 256-bit big-endian
// unsigned integer via both the slice and array methods works as expected for
// edge cases.  Random cases are tested via the various other tests.
func TestUint256SetBytes(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string    // test description
		in   string    // hex encoded test value
		want [4]uint64 // expected words
	}{{
		name: "empty",
		in:   "",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "zero",
		in:   "00",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "one",
		in:   "0000000000000000000000000000000000000000000000000000000000000001",
		want: [4]uint64{1, 0, 0, 0},
	}, {
		name: "2^64-1 (no leading zeros)",
		in:   "ffffffffffffffff",
		want: [4]uint64{0xffffffffffffffff, 0, 0, 0},
	}, {
		name: "2^128-1 (with leading zeros)",
		in:   "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
		want: [4]uint64{0xffffffffffffffff, 0xffffffffffffffff, 0, 0},
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: [4]uint64{
			0xffffffffffffffff, 0xffffffffffffffff,
			0xffffffffffffffff, 0xffffffffffffffff,
		},
	}, {
		name: "2^8 - 1 (truncated >32 bytes)",
		in:   "0100000000000000000000000000000000000000000000000000000000000000ff",
		want: [4]uint64{0xff, 0, 0, 0},
	}, {
		name: "progression",
		in:   "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20",
		want: [4]uint64{
			0x191a1b1c1d1e1f20, 0x1112131415161718,
			0x090a0b0c0d0e0f10, 0x0102030405060708,
		},
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: [4]uint64{
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
		},
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: [4]uint64{
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
		},
	}}

	for _, test := range tests {
		inBytes := hexToBytes(test.in)

		// Ensure setting the bytes via the slice method works as expected.
		var n Uint256
		n.SetByteSlice(inBytes)
		if !reflect.DeepEqual(n.n, test.want) {
			t.Errorf("%s: unexpected result -- got: %x, want: %x", test.name,
				n.n, test.want)
			continue
		}

		// Ensure setting the bytes via the array method works as expected.
		var n2 Uint256
		var b32 [32]byte
		truncatedInBytes := inBytes
		if len(truncatedInBytes) > 32 {
			truncatedInBytes = truncatedInBytes[len(truncatedInBytes)-32:]
		}
		copy(b32[32-len(truncatedInBytes):], truncatedInBytes)
		n2.SetBytes(&b32)
		if !reflect.DeepEqual(n2.n, test.want) {
			t.Errorf("%s: unexpected result -- got: %x, want: %x", test.name,
				n2.n, test.want)
			continue
		}
	}
}

// TestUint256SetBytesLE ensures that setting a uint256 to a 256-bit
// little-endian unsigned integer via both the slice and array methods works as
// expected for edge cases.
func TestUint256SetBytesLE(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string    // test description
		in   string    // hex encoded test value
		want [4]uint64 // expected words
	}{{
		name: "empty",
		in:   "",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "zero",
		in:   "00",
		want: [4]uint64{0, 0, 0, 0},
	}, {
		name: "one",
		in:   "01",
		want: [4]uint64{1, 0, 0, 0},
	}, {
		name: "2^64-1 (no trailing zeros)",
		in:   "ffffffffffffffff",
		want: [4]uint64{0xffffffffffffffff, 0, 0, 0},
	}, {
		name: "2^128-1 (with trailing zeros)",
		in:   "ffffffffffffffffffffffffffffffff00000000000000000000000000000000",
		want: [4]uint64{0xffffffffffffffff, 0xffffffffffffffff, 0, 0},
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: [4]uint64{
			0xffffffffffffffff, 0xffffffffffffffff,
			0xffffffffffffffff, 0xffffffffffffffff,
		},
	}, {
		name: "one (truncated >32 bytes)",
		in:   "0100000000000000000000000000000000000000000000000000000000000000ff",
		want: [4]uint64{1, 0, 0, 0},
	}, {
		name: "progression",
		in:   "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20",
		want: [4]uint64{
			0x0807060504030201, 0x100f0e0d0c0b0a09,
			0x1817161514131211, 0x201f1e1d1c1b1a19,
		},
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: [4]uint64{
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
			0xa5a5a5a5a5a5a5a5, 0xa5a5a5a5a5a5a5a5,
		},
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: [4]uint64{
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
			0x5a5a5a5a5a5a5a5a, 0x5a5a5a5a5a5a5a5a,
		},
	}}

	for _, test := range tests {
		inBytes := hexToBytes(test.in)

		// Ensure setting the bytes via the slice method works as expected.
		var n Uint256
		n.SetByteSliceLE(inBytes)
		if !reflect.DeepEqual(n.n, test.want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n.n, test.want)
			continue
		}

		// Ensure setting the bytes via the array method works as expected.
		var n2 Uint256
		var b32 [32]byte
		truncatedInBytes := inBytes
		if len(truncatedInBytes) > 32 {
			truncatedInBytes = truncatedInBytes[:32]
		}
		copy(b32[:], truncatedInBytes)
		n2.SetBytesLE(&b32)
		if !reflect.DeepEqual(n2.n, test.want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				n2.n, test.want)
			continue
		}
	}
}

// TestUint256Bytes ensures that retrieving the bytes for a uint256 encoded as a
// 256-bit big-endian unsigned integer via the various methods works as expected
// for edge cases.  Random cases are tested via the various other tests.
func TestUint256Bytes(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		in   string // hex encoded test value
		want string // expected hex encoded bytes
	}{{
		name: "zero",
		in:   "0",
		want: "0000000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "one",
		in:   "1",
		want: "0000000000000000000000000000000000000000000000000000000000000001",
	}, {
		name: "2^64 - 1",
		in:   "000000000000000000000000000000000000000000000000ffffffffffffffff",
		want: "000000000000000000000000000000000000000000000000ffffffffffffffff",
	}, {
		name: "2^128 - 1",
		in:   "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
		want: "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
	}, {
		name: "2^192 - 1",
		in:   "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
	}}

	for _, test := range tests {
		n := hexToUint256(test.in)
		want := hexToBytes(test.want)

		// Ensure getting the bytes works as expected.
		gotBytes := n.Bytes()
		if !bytes.Equal(gotBytes[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				gotBytes, want)
			continue
		}

		// Ensure getting the bytes directly into an array works as expected.
		var b32 [32]byte
		n.PutBytes(&b32)
		if !bytes.Equal(b32[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				b32, want)
			continue
		}

		// Ensure getting the bytes directly into a slice works as expected.
		var buffer [64]byte
		n.PutBytesUnchecked(buffer[:])
		if !bytes.Equal(buffer[:32], want) {
			t.Errorf("%q: unexpected result, got: %x, want: %x", test.name,
				buffer[:32], want)
			continue
		}
	}
}

// TestUint256BytesLE ensures that retrieving the bytes for a uint256 encoded as
// a 256-bit little-endian unsigned integer via the various methods works as
// expected for edge cases.
func TestUint256BytesLE(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		in   string // hex encoded test value
		want string // expected hex encoded bytes
	}{{
		name: "zero",
		in:   "0",
		want: "0000000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "one",
		in:   "1",
		want: "0100000000000000000000000000000000000000000000000000000000000000",
	}, {
		name: "2^64 - 1",
		in:   "000000000000000000000000000000000000000000000000ffffffffffffffff",
		want: "ffffffffffffffff000000000000000000000000000000000000000000000000",
	}, {
		name: "2^128 - 1",
		in:   "00000000000000000000000000000000ffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffff00000000000000000000000000000000",
	}, {
		name: "2^192 - 1",
		in:   "0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000",
	}, {
		name: "2^256 - 1",
		in:   "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
	}, {
		name: "alternating bits",
		in:   "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
		want: "a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5",
	}, {
		name: "alternating bits 2",
		in:   "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
		want: "5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a",
	}}

	for _, test := range tests {
		n := hexToUint256(test.in)
		want := hexToBytes(test.want)

		// Ensure getting the bytes works as expected.
		gotBytes := n.BytesLE()
		if !bytes.Equal(gotBytes[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				gotBytes, want)
			continue
		}

		// Ensure getting the bytes directly into an array works as expected.
		var b32 [32]byte
		n.PutBytesLE(&b32)
		if !bytes.Equal(b32[:], want) {
			t.Errorf("%q: unexpected result -- got: %x, want: %x", test.name,
				b32, want)
			continue
		}

		// Ensure getting the bytes directly into a slice works as expected.
		var buffer [64]byte
		n.PutBytesUncheckedLE(buffer[:])
		if !bytes.Equal(buffer[:32], want) {
			t.Errorf("%q: unexpected result, got: %x, want: %x", test.name,
				buffer[:32], want)
			continue
		}
	}
}

// TestUint256Zero ensures that zeroing a uint256 works as expected.
func TestUint256Zero(t *testing.T) {
	t.Parallel()

	n := hexToUint256("a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5")
	n.Zero()
	for idx, word := range n.n {
		if word != 0 {
			t.Errorf("internal word at index #%d is not zero - got %d", idx,
				word)
		}
	}
}

// TestUint256IsZero ensures that checking if a uint256 is zero works as
// expected.
func TestUint256IsZero(t *testing.T) {
	t.Parallel()

	var n Uint256
	if !n.IsZero() {
		t.Fatalf("new uint256 is not zero - got %v (words %x)", n, n.n)
	}

	n.SetUint64(1)
	if n.IsZero() {
		t.Fatalf("claims zero for nonzero uint256 - got %v (words %x)", n, n.n)
	}

	n.SetUint64(0)
	if !n.IsZero() {
		t.Fatalf("claims nonzero for zero uint256 - got %v (words %x)", n, n.n)
	}

	n.SetUint64(1)
	n.Zero()
	if !n.IsZero() {
		t.Fatalf("claims zero for nonzero uint256 - got %v (words %x)", n, n.n)
	}
}

// TestUint256IsUint32 ensures that checking if a uint256 can be represented as
// a uint32 without loss of precision works as expected.
func TestUint256IsUint32(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want bool   // expected result
	}{{
		name: "zero",
		n:    "0",
		want: true,
	}, {
		name: "one",
		n:    "1",
		want: true,
	}, {
		name: "two",
		n:    "2",
		want: true,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: true,
	}, {
		name: "2^32",
		n:    "100000000",
		want: false,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: false,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: false,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: false,
	}, {
		name: "2^256 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: false,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).IsUint32()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %v, want: %v", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256Uint32 ensures that treating a uint256 as a uint32 produces the
// expected result.
func TestUint256Uint32(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want uint32 // expected uint32
	}{{
		name: "zero",
		n:    "0",
		want: 0,
	}, {
		name: "one",
		n:    "1",
		want: 1,
	}, {
		name: "two",
		n:    "2",
		want: 2,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: 0xffffffff,
	}, {
		name: "2^32",
		n:    "100000000",
		want: 0,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: 0xfffffffe,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: 0xffffffff,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: 0,
	}, {
		name: "2^192 - 2^16 + 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffff0000",
		want: 0xffff0000,
	}, {
		name: "2^256 - 2^31",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffff",
		want: 0x7fffffff,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).Uint32()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256IsUint64 ensures that checking if a uint256 can be represented as
// a uint64 without loss of precision works as expected.
func TestUint256IsUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want bool   // expected result
	}{{
		name: "zero",
		n:    "0",
		want: true,
	}, {
		name: "one",
		n:    "1",
		want: true,
	}, {
		name: "two",
		n:    "2",
		want: true,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: true,
	}, {
		name: "2^32",
		n:    "100000000",
		want: true,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: true,
	}, {
		name: "2^64 - 1",
		n:    "ffffffffffffffff",
		want: true,
	}, {
		name: "2^64",
		n:    "10000000000000000",
		want: false,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: false,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: false,
	}, {
		name: "2^256 - 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		want: false,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).IsUint64()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %v, want: %v", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256Uint64 ensures that treating a uint256 as a uint64 produces the
// expected result.
func TestUint256Uint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string // test description
		n    string // hex encoded value
		want uint64 // expected uint64
	}{{
		name: "zero",
		n:    "0",
		want: 0,
	}, {
		name: "one",
		n:    "1",
		want: 1,
	}, {
		name: "two",
		n:    "2",
		want: 2,
	}, {
		name: "2^32 - 1",
		n:    "ffffffff",
		want: 0xffffffff,
	}, {
		name: "2^32",
		n:    "100000000",
		want: 0x100000000,
	}, {
		name: "2^64 - 2",
		n:    "fffffffffffffffe",
		want: 0xfffffffffffffffe,
	}, {
		name: "2^64 - 1",
		n:    "ffffffffffffffff",
		want: 0xffffffffffffffff,
	}, {
		name: "2^64",
		n:    "10000000000000000",
		want: 0,
	}, {
		name: "2^128 - 1",
		n:    "ffffffffffffffffffffffffffffffff",
		want: 0xffffffffffffffff,
	}, {
		name: "2^128",
		n:    "100000000000000000000000000000000",
		want: 0,
	}, {
		name: "2^192 - 2^16 + 1",
		n:    "ffffffffffffffffffffffffffffffffffffffffffff0000",
		want: 0xffffffffffff0000,
	}, {
		name: "2^256 - 2^63",
		n:    "ffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffff",
		want: 0x7fffffffffffffff,
	}}

	for _, test := range tests {
		got := hexToUint256(test.n).Uint64()
		if got != test.want {
			t.Errorf("%q: wrong result -- got: %x, want: %x", test.name, got,
				test.want)
			continue
		}
	}
}

// TestUint256Comparison ensures that comparing two uint256s via the various
// comparison operators works as expected for edge cases.
func TestUint256Comparison(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string // test description
		n1      string // hex encoded value
		n2      string // hex encoded value
		wantCmp int    // expected comparison result
	}{{
		name:    "0 vs 0",
		n1:      "0",
		n2:      "0",
		wantCmp: 0,
	}, {
		name:    "0 vs 1",
		n1:      "0",
		n2:      "1",
		wantCmp: -1,
	}, {
		name:    "1 vs 0",
		n1:      "1",
		n2:      "0",
		wantCmp: 1,
	}, {
		name:    "2^32 - 1 vs 2^32 - 1",
		n1:      "ffffffff",
		n2:      "ffffffff",
		wantCmp: 0,
	}, {
		name:    "2^32 - 1 vs 2^32",
		n1:      "ffffffff",
		n2:      "100000000",
		wantCmp: -1,
	}, {
		name:    "2^32 vs 2^32 - 1",
		n1:      "100000000",
		n2:      "ffffffff",
		wantCmp: 1,
	}, {
		name:    "2^32 vs 2^32",
		n1:      "100000000",
		n2:      "100000000",
		wantCmp: 0,
	}, {
		name:    "2^64 - 1 vs 2^64 - 2",
		n1:      "ffffffffffffffff",
		n2:      "fffffffffffffffe",
		wantCmp: 1,
	}, {
		name:    "2^64 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffff",
		n2:      "ffffffffffffffff",
		wantCmp: 0,
	}, {
		name:    "2^64 - 1 vs 2^64",
		n1:      "ffffffffffffffff",
		n2:      "10000000000000000",
		wantCmp: -1,
	}, {
		name:    "2^64 vs 2^64 - 1",
		n1:      "10000000000000000",
		n2:      "ffffffffffffffff",
		wantCmp: 1,
	}, {
		name:    "2^64 vs 2^64",
		n1:      "10000000000000000",
		n2:      "10000000000000000",
		wantCmp: 0,
	}, {
		name:    "2^128 - 1 vs 2^128 - 1",
		n1:      "ffffffffffffffffffffffffffffffff",
		n2:      "ffffffffffffffffffffffffffffffff",
		wantCmp: 0,
	}, {
		name:    "2^128 - 1 vs 2^128",
		n1:      "ffffffffffffffffffffffffffffffff",
		n2:      "100000000000000000000000000000000",
		wantCmp: -1,
	}, {
		name:    "2^128 vs 2^128 - 1",
		n1:      "100000000000000000000000000000000",
		n2:      "ffffffffffffffffffffffffffffffff",
		wantCmp: 1,
	}, {
		name:    "2^128 vs 2^128",
		n1:      "100000000000000000000000000000000",
		n2:      "100000000000000000000000000000000",
		wantCmp: 0,
	}, {
		name:    "2^192 - 1 vs 2^192 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		wantCmp: 0,
	}, {
		name:    "2^192 - 1 vs 2^192",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "1000000000000000000000000000000000000000000000000",
		wantCmp: -1,
	}, {
		name:    "2^192 vs 2^192 - 1",
		n1:      "1000000000000000000000000000000000000000000000000",
		n2:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		wantCmp: 1,
	}, {
		name:    "2^192 vs 2^192",
		n1:      "1000000000000000000000000000000000000000000000000",
		n2:      "1000000000000000000000000000000000000000000000000",
		wantCmp: 0,
	}, {
		name:    "2^256 - 1 vs 2^256 - 2",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe",
		wantCmp: 1,
	}, {
		name:    "2^256 - 1 vs 2^256 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		wantCmp: 0,
	}}

	for _, test := range tests {
		// Ensure comparing the numbers produces the expected == result.
		n1 := hexToUint256(test.n1)
		n2 := hexToUint256(test.n2)
		isEq := n1.Eq(n2)
		wantEq := test.wantCmp == 0
		if isEq != wantEq {
			t.Errorf("%q: incorrect == result -- got: %v, want: %v", test.name,
				isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.Lt(n2)
		wantLt := test.wantCmp < 0
		if isLt != wantLt {
			t.Errorf("%q: incorrect < result -- got: %v, want: %v", test.name,
				isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEq(n2)
		wantLtEq := test.wantCmp <= 0
		if isLtEq != wantLtEq {
			t.Errorf("%q: incorrect <= result -- got: %v, want: %v", test.name,
				isLtEq, wantLtEq)
			continue
		}
	}
}

// TestUint256ComparisonRandom ensures that comparing two uint256s created from
// random values via the various comparison operators works as expected.
func TestUint256ComparisonRandom(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		bigN2, n2 := randBigIntAndUint256(t, rng)

		// Ensure the uint256s are equal to themselves.
		if !n1.Eq(n1) {
			t.Fatalf("failed equality check -- n1: %x", n1)
		}
		if !n2.Eq(n2) {
			t.Fatalf("failed equality check -- n2: %x", n2)
		}

		// Ensure comparing the numbers produces the expected == result.
		bigCmpResult := bigN1.Cmp(bigN2)
		isEq := n1.Eq(n2)
		wantEq := bigCmpResult == 0
		if isEq != wantEq {
			t.Errorf("incorrect == result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.Lt(n2)
		wantLt := bigCmpResult < 0
		if isLt != wantLt {
			t.Errorf("incorrect < result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEq(n2)
		wantLtEq := bigCmpResult <= 0
		if isLtEq != wantLtEq {
			t.Errorf("incorrect <= result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLtEq, wantLtEq)
			continue
		}
	}
}

// TestUint256ComparisonUint64 ensures that comparing a uint256 and a uint64 via
// the various comparison operators works as expected for edge cases.
func TestUint256ComparisonUint64(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name    string // test description
		n1      string // hex encoded value
		n2      uint64 // uint64 to compare with
		wantCmp int    // expected comparison result
	}{{
		name:    "0 vs 0",
		n1:      "0",
		n2:      0,
		wantCmp: 0,
	}, {
		name:    "0 vs 1",
		n1:      "0",
		n2:      1,
		wantCmp: -1,
	}, {
		name:    "1 vs 0",
		n1:      "1",
		n2:      0,
		wantCmp: 1,
	}, {
		name:    "2^32 - 1 vs 2^32 - 1",
		n1:      "ffffffff",
		n2:      0xffffffff,
		wantCmp: 0,
	}, {
		name:    "2^32 - 1 vs 2^32",
		n1:      "ffffffff",
		n2:      0x100000000,
		wantCmp: -1,
	}, {
		name:    "2^32 vs 2^32 - 1",
		n1:      "100000000",
		n2:      0xffffffff,
		wantCmp: 1,
	}, {
		name:    "2^32 vs 2^32",
		n1:      "100000000",
		n2:      0x100000000,
		wantCmp: 0,
	}, {
		name:    "2^64 - 1 vs 2^64 - 2",
		n1:      "ffffffffffffffff",
		n2:      0xfffffffffffffffe,
		wantCmp: 1,
	}, {
		name:    "2^64 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 0,
	}, {
		name:    "2^64 vs 2^64 - 1",
		n1:      "10000000000000000",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}, {
		name:    "2^128 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffffffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}, {
		name:    "2^128 vs 0",
		n1:      "100000000000000000000000000000000",
		n2:      0,
		wantCmp: 1,
	}, {
		name:    "2^192 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}, {
		name:    "2^192 vs 0",
		n1:      "1000000000000000000000000000000000000000000000000",
		n2:      0,
		wantCmp: 1,
	}, {
		name:    "2^256 - 1 vs 2^64 - 1",
		n1:      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		n2:      0xffffffffffffffff,
		wantCmp: 1,
	}}

	for _, test := range tests {
		// Ensure comparing the numbers produces the expected == result.
		n1 := hexToUint256(test.n1)
		isEq := n1.EqUint64(test.n2)
		wantEq := test.wantCmp == 0
		if isEq != wantEq {
			t.Errorf("%q: incorrect == result -- got: %v, want: %v", test.name,
				isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.LtUint64(test.n2)
		wantLt := test.wantCmp < 0
		if isLt != wantLt {
			t.Errorf("%q: incorrect < result -- got: %v, want: %v", test.name,
				isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEqUint64(test.n2)
		wantLtEq := test.wantCmp <= 0
		if isLtEq != wantLtEq {
			t.Errorf("%q: incorrect <= result -- got: %v, want: %v", test.name,
				isLt, wantLtEq)
			continue
		}
	}
}

// TestUint256ComparisonUint64Random ensures that comparing a uint256 vs uint64
// created from random values via the various comparison operators works as
// expected.
func TestUint256ComparisonUint64Random(t *testing.T) {
	t.Parallel()

	// Use a unique random seed each test instance and log it if the tests fail.
	seed := time.Now().Unix()
	rng := rand.New(rand.NewSource(seed))
	defer func(t *testing.T, seed int64) {
		if t.Failed() {
			t.Logf("random seed: %d", seed)
		}
	}(t, seed)

	for i := 0; i < 100; i++ {
		// Generate two big integer and uint256/uint64 pairs.
		bigN1, n1 := randBigIntAndUint256(t, rng)
		n2 := rng.Uint64()
		bigN2 := new(big.Int).SetUint64(n2)

		// Ensure a the uint256 truncated to 64 bits equals that truncated
		// 64-bit result.
		truncatedN1Uint64 := n1.Uint64()
		truncatedN1 := new(Uint256).SetUint64(truncatedN1Uint64)
		if !truncatedN1.EqUint64(truncatedN1Uint64) {
			t.Fatalf("failed equality check -- n: %x", truncatedN1)
		}

		// Ensure comparing the numbers produces the expected == result.
		bigCmpResult := bigN1.Cmp(bigN2)
		isEq := n1.EqUint64(n2)
		wantEq := bigCmpResult == 0
		if isEq != wantEq {
			t.Errorf("incorrect == result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isEq, wantEq)
			continue
		}

		// Ensure comparing the numbers produces the expected < result.
		isLt := n1.LtUint64(n2)
		wantLt := bigCmpResult < 0
		if isLt != wantLt {
			t.Errorf("incorrect < result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLt, wantLt)
			continue
		}

		// Ensure comparing the numbers produces the expected <= result.
		isLtEq := n1.LtEqUint64(n2)
		wantLtEq := bigCmpResult <= 0
		if isLtEq != wantLtEq {
			t.Errorf("incorrect <= result n1: %x, n2: %x -- got: %v, want: %v",
				n1, n2, isLtEq, wantLtEq)
			continue
		}
	}
}
